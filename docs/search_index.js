var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#Scalar-and-vector-fields","page":"Guide","title":"Scalar & vector fields","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Scalar & vector fields are represented as 2d/3d arrays of canonically scalars or vectors. Array values can alternatively be any type that Supports addition & multiplication.","category":"page"},{"location":"guide/#Customizable-grid","page":"Guide","title":"Customizable grid","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Grid","category":"page"},{"location":"guide/#Main.EquivariantOperators.Grid","page":"Guide","title":"Main.EquivariantOperators.Grid","text":"Grid(cell, rmax::AbstractFloat)\nGrid(\n    cell::AbstractMatrix,\n    sz::Union{AbstractVector,Tuple};\n    origin = (sz .+ 1) ./ 2,\n    )\n\nGrid is specified by its discrete cell vectors (column-wise matrix), overall size and origin. For a uniform Cartesian 5x5 grid discretized at 0.1 with a centered origin, we get cell = [0.1 0; 0 0.1] & origin = [3, 3]. Grid cell can in general be noncartesian.\n\n\n\n\n\n","category":"type"},{"location":"guide/#Particle-mesh-placement-and-interpolation","page":"Guide","title":"Particle mesh placement and interpolation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"get(::AbstractArray, ::Grid, ::AbstractVector)","category":"page"},{"location":"guide/#Base.get-Tuple{AbstractArray, Grid, AbstractVector}","page":"Guide","title":"Base.get","text":"Base.get(field::AbstractArray, grid::Grid, rvec::AbstractVector)\nBase.put!(\n    field::AbstractArray,\n    grid::Grid,\n    rvec::AbstractVector,\n    val::AbstractVector,\n)\n\nWith grid info we can interpolate a scalar or vector field at any location. We can also place a scalar or vector point source anywhere with automatic normalization wrt discretization. Both work via a proximity weighted average of the closest grid points (in general up to 4 in 2d and 8 in 3d).\n\n\n\n\n\n","category":"method"},{"location":"guide/#Finite-difference-operators","page":"Guide","title":"Finite difference operators","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Op","category":"page"},{"location":"guide/#Main.EquivariantOperators.Op","page":"Guide","title":"Main.EquivariantOperators.Op","text":"Op(\n    name::Union{Symbol,String},\n    cell;\n    boundary =:same,\n    rmin = 0,\n    rmax = Inf,\n    l = 0,\n    σ = 1.0,\n)\nOp(\n    radfunc,\n    rmin::AbstractFloat,\n    rmax::AbstractFloat,\n    cell;\n    l = 0,\n    boundary =:same,\n)\n\nOp constructs finite difference operators. Prebuilt operators like differential operators (▽) & common Green's functions can be specified by name. Custom equivariant operators can be made by specifying radial function.\n\n\n\n\n\nfunction (m::Op)(x::AbstractArray, )\n\n\n\n\n\n","category":"type"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Synopsis","page":"Home","title":"Synopsis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EquivariantOperators.jl implements in Julia fully differentiable finite difference operators on scalar or vector fields in 2d/3d. It can run forwards for PDE simulation or image processing, or back propagated for machine learning or inverse problems. Emphasis is on symmetry preserving rotation equivariant operators, including differential operators, common Green's functions & parametrized neural operators. Supports possibly nonuniform, nonorthogonal or periodic grids.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hosted on Colab notebooks","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Equivariant linear operators are our building blocks. Equivariance means a rotation of the input results in the same rotation of the output thus preserving symmetry. Applying a linear operator convolves the input with the operator's kernel. If the operator is also equivariant, then its kernel must be radially symmetric. Differential operators and Green's functions are in fact equivariant linear operators. We provide built in constructors for these common operators. By parameterizing the radial function, we can also construct custom neural equivariant operators for machine learning.","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Preprint: Paul Shen, Michael Herbst, Venkat Viswanathan. Rotation Equivariant Fourier Neural Operators for Learning Symmetry Preserving Transformations on Scalar Fields, Vector Fields, and Higher Order Tensor Fields. Arxiv. 2021.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Shen (xingpins@andrew.cmu.edu), Michael Herbst (herbst@acom.rwth-aachen.de), Venkat Viswanathan (venkatv@andrew.cmu.edu)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In consultation with Rachel Kurchin, Dhairya Gandhi, Chris Rackauckas","category":"page"},{"location":"","page":"Home","title":"Home","text":"In collaboration with Julia Computing","category":"page"}]
}
